# ============================================================
# Part 1: Data Preparation (run once)
# Outputs:
#   1) ./supplementary/fips_to_iso3_completed.csv   (completed mapping table)
#   2) ./supplementary/precip_2024_by_country.csv   (country-level averages)
# ============================================================

import os
import pandas as pd
import geopandas as gpd
from pyspark.sql import functions as F

spark.conf.set("spark.sql.execution.arrow.pyspark.enabled", "true")

# ---------- 0) Base FIPS→ISO3 dictionary (common countries; others will be auto-completed) ----------
FIPS_TO_ISO3_BASE = { ... }  # (use your complete dictionary here)

# ---------- 1) Aggregate precipitation in Spark ----------
prcp_2024 = (
    daily_prcp
    .filter(F.col("year") == 2024)
    .select("ID", "PRCP_VALUE")
    .groupBy("ID")
    .agg(F.avg("PRCP_VALUE").alias("PRCP_2024_station_avg"))
)

station_country = prcp_stations.select("ID", "COUNTRY_CODE").dropna().dropDuplicates(["ID"])

country_avg_2024 = (
    prcp_2024.join(station_country, on="ID", how="inner")
    .groupBy("COUNTRY_CODE")
    .agg(
        F.avg("PRCP_2024_station_avg").alias("PRCP_2024_country_avg"),
        F.countDistinct("ID").alias("n_stations_2024")
    )
)

avg_pdf = country_avg_2024.toPandas()

# ---------- 2) Apply FIPS→ISO3 mapping ----------
avg_pdf["iso_a3"] = avg_pdf["COUNTRY_CODE"].map(FIPS_TO_ISO3_BASE)

# ---------- 3) For unmapped FIPS codes, auto-complete using spatial join ----------
need_fill = avg_pdf[avg_pdf["iso_a3"].isna()]["COUNTRY_CODE"].unique().tolist()

if len(need_fill) > 0:
    # Representative coordinates for each missing FIPS (mean latitude/longitude)
    fips_reps = (
        prcp_stations
        .select("COUNTRY_CODE", "LATITUDE", "LONGITUDE")
        .where(F.col("COUNTRY_CODE").isin(need_fill))
        .groupBy("COUNTRY_CODE")
        .agg(F.avg("LATITUDE").alias("avg_lat"), F.avg("LONGITUDE").alias("avg_lon"))
        .toPandas()
    )

    reps_gdf = gpd.GeoDataFrame(
        fips_reps,
        geometry=gpd.points_from_xy(fips_reps["avg_lon"], fips_reps["avg_lat"]),
        crs="EPSG:4326"
    )

    world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres")).to_crs(4326)
    world = world[~world["iso_a3"].isin(["-99"])][["iso_a3", "name", "geometry"]]

    # Spatial join (point-in-polygon) to assign missing FIPS to countries
    reps_joined = gpd.sjoin(reps_gdf, world, how="left", predicate="within")

    filled_map = dict(zip(reps_joined["COUNTRY_CODE"], reps_joined["iso_a3"]))
    FIPS_TO_ISO3_COMPLETED = {**FIPS_TO_ISO3_BASE, **filled_map}
else:
    FIPS_TO_ISO3_COMPLETED = FIPS_TO_ISO3_BASE.copy()

avg_pdf["iso_a3"] = avg_pdf["iso_a3"].fillna(avg_pdf["COUNTRY_CODE"].map(FIPS_TO_ISO3_COMPLETED))

# ---------- 4) Save results ----------
os.makedirs("./supplementary", exist_ok=True)

pd.Series(FIPS_TO_ISO3_COMPLETED).rename("ISO3").to_csv(
    "./supplementary/fips_to_iso3_completed.csv", header=True
)

avg_pdf[["iso_a3", "COUNTRY_CODE", "PRCP_2024_country_avg", "n_stations_2024"]]\
    .to_csv("./supplementary/precip_2024_by_country.csv", index=False)

print("✓ Saved mapping to ./supplementary/fips_to_iso3_completed.csv")
print("✓ Saved country table to ./supplementary/precip_2024_by_country.csv")





# --------
# --------
# --------


# ============================================================
# Part 2: Plotting (can be rerun multiple times)
# Input:  ./supplementary/precip_2024_by_country.csv
# Output: ./supplementary/precip_2024_choropleth_robinson_axes.png
# ============================================================

import os
import numpy as np
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER

# ---------- 1) Load prepared country averages ----------
avg_pdf = pd.read_csv("./supplementary/precip_2024_by_country.csv")

# ---------- 2) Load world basemap (Natural Earth) ----------
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres")).to_crs(4326)
world = world[~world["iso_a3"].isin(["-99"])]
world_join = world.merge(avg_pdf, on="iso_a3", how="left")

# ---------- 3) Set projections ----------
proj_display = ccrs.Robinson()
proj_geo = ccrs.PlateCarree()  # Data CRS = WGS84

# ---------- 4) Plot ----------
fig = plt.figure(figsize=(16, 8))
ax = plt.axes(projection=proj_display)

world_join.to_crs(4326).plot(
    ax=ax,
    transform=proj_geo,
    column="PRCP_2024_country_avg",
    cmap="YlGnBu",
    legend=True,
    legend_kwds={"label": "Average Rainfall in 2024 (country mean of station means)"},
    edgecolor="#d3d9df",
    linewidth=0.4,
    missing_kwds={"color": "#f0f0f0", "edgecolor": "#d3d9df", "hatch": "///", "label": "No data"},
)

# ---------- 5) Gridlines with lat/lon labels (only left/bottom) ----------
gl = ax.gridlines(
    crs=proj_geo, draw_labels=True,
    xlocs=np.arange(-180, 181, 30),
    ylocs=np.arange(-60, 91, 15),
    linestyle=":", linewidth=0.6, alpha=0.6, color="k"
)
gl.top_labels = False
gl.right_labels = False
gl.xlabel_style = {"size": 9}
gl.ylabel_style = {"size": 9}
gl.xformatter = LONGITUDE_FORMATTER
gl.yformatter = LATITUDE_FORMATTER

# ---------- 6) Title and extent ----------
ax.set_global()
ax.set_title("Average Rainfall by Country (2024)\nCRS: ESRI:54030  •  Grey hatched = No data", fontsize=13)

# ---------- 7) Ensure "No data" legend entry ----------
handles, labels = ax.get_legend_handles_labels()
if "No data" not in labels:
    import matplotlib.patches as mpatches
    handles.append(mpatches.Patch(facecolor="#f0f0f0", edgecolor="#d3d9df", hatch="///", label="No data"))
    ax.legend(handles=handles, loc="lower left")

# ---------- 8) Save ----------
out_png = "./supplementary/precip_2024_choropleth_robinson_axes.png"
plt.tight_layout()
plt.savefig(out_png, dpi=300, bbox_inches="tight")
plt.show()

print("✓ Saved map to", out_png)